From d137eff9e4b169ae4652f4e16c56a5175736163d Mon Sep 17 00:00:00 2001
From: Michael Catanzaro <mcatanzaro@redhat.com>
Date: Fri, 8 Dec 2023 10:13:50 -0600
Subject: [PATCH 1/2] Fix a typo and rename a variable in create_hash_table
 script https://bugs.webkit.org/show_bug.cgi?id=266029

Reviewed by NOBODY (OOPS!).

This just fixes a typo, and also renames a confusing/misleading variable.

* Source/JavaScriptCore/create_hash_table:
---
 Source/JavaScriptCore/create_hash_table | 16 ++++++++--------
 1 file changed, 8 insertions(+), 8 deletions(-)

diff --git a/Source/JavaScriptCore/create_hash_table b/Source/JavaScriptCore/create_hash_table
index bd604ceaa8c96..6efe1c17602ab 100755
--- a/Source/JavaScriptCore/create_hash_table
+++ b/Source/JavaScriptCore/create_hash_table
@@ -42,7 +42,7 @@ my $hasSetter = "false";
 my $includeBuiltin = 0;
 my $inside = 0;
 my $name;
-my $pefectHashSize;
+my $perfectHashSize;
 my $compactSize;
 my $compactHashSizeMask;
 my $banner = 0;
@@ -133,10 +133,10 @@ sub jsc_ucfirst($)
 
 sub ceilingToPowerOf2
 {
-    my ($pefectHashSize) = @_;
+    my ($perfectHashSize) = @_;
 
     my $powerOf2 = 1;
-    while ($pefectHashSize > $powerOf2) {
+    while ($perfectHashSize > $powerOf2) {
         $powerOf2 <<= 1;
     }
 
@@ -147,10 +147,10 @@ sub calcPerfectHashSize($)
 {
     my ($isMac) = @_;
 tableSizeLoop:
-    for ($pefectHashSize = ceilingToPowerOf2(scalar @keys); ; $pefectHashSize += $pefectHashSize) {
+    for ($perfectHashSize = ceilingToPowerOf2(scalar @keys); ; $perfectHashSize += $perfectHashSize) {
         my @table = ();
         foreach my $key (@keys) {
-            my $h = hashValue($key, $isMac) % $pefectHashSize;
+            my $h = hashValue($key, $isMac) % $perfectHashSize;
             next tableSizeLoop if $table[$h];
             $table[$h] = 1;
         }
@@ -525,10 +525,10 @@ sub output() {
     };
 
     my $hashTableForMacOS = generateHashTableHelper(1, 1);
-    my $hashTableForIOS = generateHashTableHelper(0, 0);
+    my $hashTableForNonMacOSPlatforms = generateHashTableHelper(0, 0);
     my $hashTableToWrite = $hashTableForMacOS;
-    if ($hashTableForMacOS ne $hashTableForIOS) {
-        $hashTableToWrite = "#if PLATFORM(MAC)\n" . $hashTableForMacOS . "#else\n" . $hashTableForIOS . "#endif\n";
+    if ($hashTableForMacOS ne $hashTableForNonMacOSPlatforms) {
+        $hashTableToWrite = "#if PLATFORM(MAC)\n" . $hashTableForMacOS . "#else\n" . $hashTableForNonMacOSPlatforms . "#endif\n";
     }
     print $hashTableToWrite;
 

From d5913d8fe5fb741807ae6b4ac11d1fe1dfd9f5e5 Mon Sep 17 00:00:00 2001
From: Michael Catanzaro <mcatanzaro@redhat.com>
Date: Fri, 8 Dec 2023 10:13:50 -0600
Subject: [PATCH 2/2] Revert 267629@main and add safety check to
 create_hash_table https://bugs.webkit.org/show_bug.cgi?id=265554

Reviewed by NOBODY (OOPS!).

bigint and Math::BigInt are two completely different perl modules.
bigint causes the entire script to transparently use Math::BigInt for
mathematical operations. Importing the wrong module effectively sabotaged
the script. Whoops.

bigint appears to be part of a standard perl installation, so for
upstream purposes we can expect it to be always available. However,
Fedora packages the perl interpreter separately from its modules. When I
went to install the bigint module, I tricked myself into thinking it was
already installed because Math::BigInt was installed, and another
developer suggested that the import syntax was wrong, and I improperly
went along with this because I am not very familiar with perl.

So, fix the import syntax to make this script actually use big integers
again. This fixes an infinite loop on 32-bit platforms if perl is not
compiled with 64-bit integer support. It might possibly fix other
problems too; not sure.

Also, add new safety checks to ensure the script fails if the hash
size grows too large. This will prevent the script from infinite looping
if somebody else breaks the script in the future.

* Source/JavaScriptCore/create_hash_table:
* Source/WebCore/bindings/scripts/Hasher.pm:
---
 Source/JavaScriptCore/create_hash_table   | 13 +++++++++++--
 Source/WebCore/bindings/scripts/Hasher.pm |  2 +-
 2 files changed, 12 insertions(+), 3 deletions(-)

diff --git a/Source/JavaScriptCore/create_hash_table b/Source/JavaScriptCore/create_hash_table
index 6efe1c17602ab..9924edd28b256 100755
--- a/Source/JavaScriptCore/create_hash_table
+++ b/Source/JavaScriptCore/create_hash_table
@@ -24,7 +24,7 @@
  
 use strict;
 use warnings;
-use Math::BigInt;
+use bigint;
 use Getopt::Long qw(:config pass_through);
 
 my $file = shift @ARGV or die("Must provide source file as final argument.");
@@ -148,6 +148,9 @@ sub calcPerfectHashSize($)
     my ($isMac) = @_;
 tableSizeLoop:
     for ($perfectHashSize = ceilingToPowerOf2(scalar @keys); ; $perfectHashSize += $perfectHashSize) {
+        if ($perfectHashSize > 2**15) {
+            die "The hash size is far too big. This should not be reached.";
+        }
         my @table = ();
         foreach my $key (@keys) {
             my $h = hashValue($key, $isMac) % $perfectHashSize;
@@ -176,6 +179,12 @@ sub calcCompactHashSize($)
         my $depth = 0;
         my $h = hashValue($key, $isMac) % $compactHashSize;
         while (defined($table[$h])) {
+            if ($compactSize > 1000) {
+                die "The hash size is far too big. This should not be reached.";
+            }
+            if ($depth > 100) {
+                die "The depth is far too big. This should not be reached.";
+            }
             if (defined($links[$h])) {
                 $h = $links[$h];
                 $depth++;
@@ -188,7 +197,7 @@ sub calcCompactHashSize($)
         }
         $table[$h] = $i;
         $i++;
-        $maxdepth = $depth if ( $depth > $maxdepth);
+        $maxdepth = $depth if ($depth > $maxdepth);
     }
 }
 
diff --git a/Source/WebCore/bindings/scripts/Hasher.pm b/Source/WebCore/bindings/scripts/Hasher.pm
index fd46f9e05a66d..bef5019220480 100644
--- a/Source/WebCore/bindings/scripts/Hasher.pm
+++ b/Source/WebCore/bindings/scripts/Hasher.pm
@@ -27,7 +27,7 @@
 package Hasher;
 
 use strict;
-use Math::BigInt;
+use bigint;
 
 my $mask64 = 2**64 - 1;
 my $mask32 = 2**32 - 1;
