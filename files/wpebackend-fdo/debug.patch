From 95317b04e2d28120496c51aa023e13293dae3aa9 Mon Sep 17 00:00:00 2001
From: Michael Catanzaro <mcatanzaro@gnome.org>
Date: Sat, 4 Jan 2020 10:47:00 -0600
Subject: [PATCH] Make WS::Instance::initialize crash on failure

We need crashes here to debug
https://bugs.webkit.org/show_bug.cgi?id=201507. Otherwise, we're never
going to figure out what is going wrong. I decided to use g_error()
rather than g_warning() because we are going to want to be able to
examine stack and member variables to see as much of what went wrong as
possible. Having a backtrace will be much more useful for debugging than
just having a warning.

But because the function is designed to return false on failure, and
this commit subverts that, we will eventually want to revert this,
either turning the crashes into warnings or just removing the warnings
entirely. I've added a FIXME so we don't forget to do this.
---
 src/ws.cpp | 20 ++++++++++++++++----
 1 file changed, 16 insertions(+), 4 deletions(-)

diff --git a/src/ws.cpp b/src/ws.cpp
index 53a6702..b588060 100644
--- a/src/ws.cpp
+++ b/src/ws.cpp
@@ -336,11 +336,17 @@ static bool isEGLExtensionSupported(const char* extensionList, const char* exten
 
 bool Instance::initialize(EGLDisplay eglDisplay)
 {
+    /* FIXME: Replace g_error() with g_warning() after https://bugs.webkit.org/show_bug.cgi?id=201507
+     * has been debugged and resolved. g_error() does not return, so the "return false" statements
+     * below are all currently unreachable dead code. They are kept so that you can simply replace
+     * each g_error() with g_warning() in the future without otherwise modifying the code.
+     */
+
     if (m_eglDisplay == eglDisplay)
         return true;
 
     if (m_eglDisplay != EGL_NO_DISPLAY) {
-        fprintf(stderr, "WPE fdo doesn't support multiple EGL displays\n");
+        g_error("Failed to initialize WS::Instance: multiple EGL displays are not supported.");
         return false;
     }
 
@@ -351,8 +357,10 @@ bool Instance::initialize(EGLDisplay eglDisplay)
         s_eglQueryWaylandBufferWL = reinterpret_cast<PFNEGLQUERYWAYLANDBUFFERWL>(eglGetProcAddress("eglQueryWaylandBufferWL"));
         assert(s_eglQueryWaylandBufferWL);
     }
-    if (!s_eglBindWaylandDisplayWL || !s_eglQueryWaylandBufferWL)
+    if (!s_eglBindWaylandDisplayWL || !s_eglQueryWaylandBufferWL) {
+        g_error("Failed to initialize WS::Instance: EGL_WL_bind_wayland_display not supported");
         return false;
+    }
 
     if (isEGLExtensionSupported(extensions, "EGL_KHR_image_base")) {
         s_eglCreateImageKHR = reinterpret_cast<PFNEGLCREATEIMAGEKHRPROC>(eglGetProcAddress("eglCreateImageKHR"));
@@ -360,11 +368,15 @@ bool Instance::initialize(EGLDisplay eglDisplay)
         s_eglDestroyImageKHR = reinterpret_cast<PFNEGLDESTROYIMAGEKHRPROC>(eglGetProcAddress("eglDestroyImageKHR"));
         assert(s_eglDestroyImageKHR);
     }
-    if (!s_eglCreateImageKHR || !s_eglDestroyImageKHR)
+    if (!s_eglCreateImageKHR || !s_eglDestroyImageKHR) {
+        g_error("Failed to initialize WS::Instance: EGL_KHR_image_base not supported");
         return false;
+    }
 
-    if (!s_eglBindWaylandDisplayWL(eglDisplay, m_display))
+    if (!s_eglBindWaylandDisplayWL(eglDisplay, m_display)) {
+        g_error("Failed to initialize WS::Instance: eglBindWaylandDisplayWL failed");
         return false;
+    }
 
     m_eglDisplay = eglDisplay;
 
-- 
2.24.1

