From 28418143601249885882e417628952b970614033 Mon Sep 17 00:00:00 2001
From: Valentin David <me@valentindavid.com>
Date: Wed, 7 May 2025 21:49:00 +0200
Subject: [PATCH 2/2] auth-dlg: Switch to gtk4 and webkitgtk 6

---
 .obs/debian/control                   |  12 +-
 .obs/network-manager-openconnect.spec |   5 +-
 Makefile.am                           |   9 +-
 auth-dialog/main.c                    | 329 ++++++++++++--------------
 configure.ac                          |  38 ++-
 5 files changed, 186 insertions(+), 207 deletions(-)

diff --git a/.obs/debian/control b/.obs/debian/control
index 30a40ae..4407b5d 100644
--- a/.obs/debian/control
+++ b/.obs/debian/control
@@ -4,16 +4,14 @@ Section: net
 Priority: optional
 Build-Depends: debhelper-compat (= 12),
                intltool,
-               libgcr-3-dev,
+               libgcr-4-dev,
                libglib2.0-dev,
-               libgtk-3-dev,
-# Added via OBS prjconf, so that it still builds on older Ubuntu/Debian versions
-#               libgtk-4-bin,
-#               libgtk-4-dev,
+               libgtk-4-bin,
+               libgtk-4-dev,
                libnm-dev,
                libnma-dev,
-#               libnma-gtk4-dev,
-               libwebkit2gtk-4.0-dev,
+               libnma-gtk4-dev,
+               libwebkitgtk-6.0-dev,
                libopenconnect-dev (>= 8.20~),
                libsecret-1-dev,
                libxml2-dev
diff --git a/.obs/network-manager-openconnect.spec b/.obs/network-manager-openconnect.spec
index 57d00ab..8e4c1f9 100644
--- a/.obs/network-manager-openconnect.spec
+++ b/.obs/network-manager-openconnect.spec
@@ -19,7 +19,6 @@ Source:    https://download.gnome.org/sources/NetworkManager-openconnect/1.2/net
 
 BuildRequires: make
 BuildRequires: gcc
-BuildRequires: pkgconfig(gtk+-3.0) >= %{gtk3_version}
 BuildRequires: pkgconfig(libnm) >= %{nm_version}
 BuildRequires: pkgconfig(libnma) >= %{nm_version}
 BuildRequires: pkgconfig(libsecret-1)
@@ -27,11 +26,11 @@ BuildRequires: pkgconfig(glib-2.0)
 BuildRequires: intltool gettext libtool
 BuildRequires: pkgconfig(libxml-2.0)
 BuildRequires: pkgconfig(openconnect) >= %{openconnect_version}
-BuildRequires: pkgconfig(gcr-3) >= 3.4
-BuildRequires: pkgconfig(webkit2gtk-4.0)
 %if %with gtk4
+BuildRequires: pkgconfig(gcr-4) >= 4.0
 BuildRequires: pkgconfig(gtk4) >= 4.0
 BuildRequires: pkgconfig(libnma-gtk4) >= 1.8.33
+BuildRequires: pkgconfig(webkitgtk-6.0)
 %endif
 
 Requires: NetworkManager   >= %{nm_version}
diff --git a/Makefile.am b/Makefile.am
index 487043c..3fb275d 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -63,14 +63,15 @@ src_nm_openconnect_service_openconnect_helper_LDADD = \
 plugindir = $(libdir)/NetworkManager
 plugin_LTLIBRARIES += properties/libnm-vpn-plugin-openconnect.la
 if WITH_GNOME
+if WITH_GTK4
+plugin_LTLIBRARIES += properties/libnm-gtk4-vpn-plugin-openconnect-editor.la
+else
 plugin_LTLIBRARIES += properties/libnm-vpn-plugin-openconnect-editor.la
+endif
 if WITH_LIBNM_GLIB
 plugin_LTLIBRARIES += properties/libnm-openconnect-properties.la
 endif
 endif
-if WITH_GTK4
-plugin_LTLIBRARIES += properties/libnm-gtk4-vpn-plugin-openconnect-editor.la
-endif
 
 properties/resources.h: properties/gresource.xml
 	$(AM_V_GEN) $(GLIB_COMPILE_RESOURCES) $< --target=$@ --sourcedir=$(srcdir)/properties --generate-header --internal
@@ -240,7 +241,7 @@ auth_dialog_nm_openconnect_auth_dialog_CPPFLAGS = \
 	$(LIBNM_CFLAGS) \
 	$(GLIB_CFLAGS) \
 	$(WEBKIT_CFLAGS) \
-	$(GTK_CFLAGS) \
+	$(GTK4_CFLAGS) \
 	$(GCR_CFLAGS) \
 	$(OPENCONNECT_CFLAGS) \
 	$(LIBXML_CFLAGS) \
diff --git a/auth-dialog/main.c b/auth-dialog/main.c
index 875979e..ec7e283 100644
--- a/auth-dialog/main.c
+++ b/auth-dialog/main.c
@@ -36,7 +36,7 @@
 #include <gtk/gtk.h>
 #include <glib-unix.h>
 
-#include <webkit2/webkit2.h>
+#include <webkit/webkit.h>
 #include <libsoup/soup.h>
 
 #include <gcr/gcr.h>
@@ -164,7 +164,7 @@ typedef struct auth_ui_data {
 	GHashTable *success_passwords;
 	struct openconnect_info *vpninfo;
 	GtkWidget *dialog;
-	GtkWidget *combo;
+	GtkWidget *drop_down;
 	GtkWidget *connect_button;
 	GtkWidget *no_form_label;
 	GtkWidget *getting_form_label;
@@ -208,6 +208,8 @@ typedef struct auth_ui_data {
 
 	int autosubmit;
 	int fields_pending;
+
+	GtkApplication* application;
 } auth_ui_data;
 
 enum {
@@ -224,27 +226,19 @@ static void connect_host(auth_ui_data *ui_data);
 
 static void write_progress(void *cbdata, int level, const char *fmt, ...);
 
-static void container_child_remove(GtkWidget *widget, gpointer data)
-{
-	GtkContainer *container = GTK_CONTAINER(data);
-
-	gtk_container_remove(container, widget);
-}
-
 static void ssl_box_add_error(auth_ui_data *ui_data, const char *msg)
 {
 	GtkWidget *hbox, *text, *image;
 
 	hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 8);
-	gtk_box_pack_start(GTK_BOX(ui_data->ssl_box), hbox, FALSE, FALSE, 0);
+	gtk_box_append(GTK_BOX(ui_data->ssl_box), hbox);
 
-	image = gtk_image_new_from_icon_name("dialog-error",
-					     GTK_ICON_SIZE_DIALOG);
-	gtk_box_pack_start(GTK_BOX(hbox), image, FALSE, FALSE, 0);
+	image = gtk_image_new_from_icon_name("dialog-error");
+	gtk_box_append(GTK_BOX(hbox), image);
 
 	text = gtk_label_new(msg);
-	gtk_label_set_line_wrap(GTK_LABEL(text), TRUE);
-	gtk_box_pack_start(GTK_BOX(hbox), text, TRUE, TRUE, 0);
+	gtk_label_set_wrap(GTK_LABEL(text), TRUE);
+	gtk_box_append(GTK_BOX(hbox), text);
 	ui_data->last_notice_icon = NULL;
 }
 
@@ -253,16 +247,14 @@ static void ssl_box_add_notice(auth_ui_data *ui_data, const char *msg)
 	GtkWidget *hbox, *text, *image;
 
 	hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 8);
-	gtk_box_pack_start(GTK_BOX(ui_data->ssl_box), hbox, FALSE, FALSE, 0);
+	gtk_box_append(GTK_BOX(ui_data->ssl_box), hbox);
 
-	image = gtk_image_new_from_icon_name("dialog-warning",
-					     GTK_ICON_SIZE_DIALOG);
-	gtk_box_pack_start(GTK_BOX(hbox), image, FALSE, FALSE, 0);
+	image = gtk_image_new_from_icon_name("dialog-warning");
+	gtk_box_append(GTK_BOX(hbox), image);
 
 	text = gtk_label_new(msg);
-	gtk_label_set_line_wrap(GTK_LABEL(text), TRUE);
-	gtk_box_pack_start(GTK_BOX(hbox), text, TRUE, TRUE, 0);
-	gtk_widget_show_all(ui_data->ssl_box);
+	gtk_label_set_wrap(GTK_LABEL(text), TRUE);
+	gtk_box_append(GTK_BOX(hbox), text);
 	ui_data->last_notice_icon = image;
 }
 
@@ -272,20 +264,25 @@ static void ssl_box_add_info(auth_ui_data *ui_data, const char *msg)
 	int width;
 
 	text = gtk_label_new(msg);
-	gtk_label_set_line_wrap(GTK_LABEL(text), TRUE);
-	gtk_window_get_size(GTK_WINDOW(ui_data->dialog), &width, NULL);
+	gtk_label_set_wrap(GTK_LABEL(text), TRUE);
+	gtk_window_get_default_size(GTK_WINDOW(ui_data->dialog), &width, NULL);
 	/* FIXME: this is not very nice -- can't make the window thinner after this */
 	gtk_widget_set_size_request(text, width - 40, -1);
-	gtk_box_pack_start(GTK_BOX(ui_data->ssl_box), text, FALSE, FALSE, 0);
+	gtk_box_append(GTK_BOX(ui_data->ssl_box), text);
 }
 
 static void ssl_box_clear(auth_ui_data *ui_data)
 {
+	GtkWidget* child;
+
 	gtk_widget_hide(ui_data->no_form_label);
 	gtk_widget_hide(ui_data->getting_form_label);
 	ui_data->last_notice_icon = NULL;
-	gtk_container_foreach(GTK_CONTAINER(ui_data->ssl_box),
-			      container_child_remove, ui_data->ssl_box);
+	for (child = gtk_widget_get_first_child(GTK_WIDGET(ui_data->ssl_box));
+	     child != NULL;
+	     child = gtk_widget_get_first_child(GTK_WIDGET(ui_data->ssl_box))) {
+	  gtk_box_remove(GTK_BOX(ui_data->ssl_box), child);
+	}
 	gtk_widget_set_sensitive (ui_data->login_button, FALSE);
 	gtk_widget_set_sensitive (ui_data->cancel_button, FALSE);
 }
@@ -315,7 +312,7 @@ static void evaluate_login_visibility(auth_ui_data *ui_data)
 static void entry_changed(GtkEntry *entry, ui_fragment_data *data)
 {
 	g_free (data->entry_text);
-	data->entry_text = g_strdup(gtk_entry_get_text(entry));
+	data->entry_text = g_strdup(gtk_entry_buffer_get_text(gtk_entry_get_buffer(entry)));
 }
 
 static void do_override_label(ui_fragment_data *data, struct oc_choice *choice)
@@ -338,10 +335,10 @@ static gboolean do_newgroup(GtkDialog *dialog)
 	return FALSE;
 }
 
-static void combo_changed(GtkComboBox *combo, ui_fragment_data *data)
+static void drop_down_changed(GtkDropDown *drop_down, ui_fragment_data *data)
 {
 	struct oc_form_opt_select *sopt = (void *)data->opt;
-	int entry = gtk_combo_box_get_active(combo);
+	int entry = gtk_drop_down_get_selected(drop_down);
 	if (entry < 0)
 		return;
 
@@ -368,19 +365,19 @@ static gboolean ui_write_prompt (ui_fragment_data *data)
 	visible = (data->opt->type == OC_FORM_OPT_TEXT);
 
 	hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
-	gtk_box_pack_start(GTK_BOX(data->ui_data->ssl_box), hbox, FALSE, FALSE, 0);
+	gtk_box_append(GTK_BOX(data->ui_data->ssl_box), hbox);
 
 	text = gtk_label_new(label);
-	gtk_box_pack_start(GTK_BOX(hbox), text, FALSE, FALSE, 0);
+	gtk_box_append(GTK_BOX(hbox), text);
 	data->widget = text;
 
 	entry = gtk_entry_new();
-	gtk_box_pack_end(GTK_BOX(hbox), entry, FALSE, FALSE, 0);
+	gtk_box_append(GTK_BOX(hbox), entry);
 	data->entry = entry;
 	if (!visible)
 		gtk_entry_set_visibility(GTK_ENTRY(entry), FALSE);
 	if (data->entry_text)
-		gtk_entry_set_text(GTK_ENTRY(entry), data->entry_text);
+		gtk_entry_buffer_set_text(gtk_entry_get_buffer(GTK_ENTRY(entry)), data->entry_text, -1);
 	/* If it's the first empty one, grab focus. Otherwise, if
 	   it's the first item of *any* kind, grab focus but don't
 	   admit it (so another empty entry can take focus_ */
@@ -401,21 +398,29 @@ static gboolean ui_write_prompt (ui_fragment_data *data)
 static gboolean ui_add_select (ui_fragment_data *data)
 {
 	auth_ui_data *ui_data = _ui_data; /* FIXME global */
-	GtkWidget *hbox, *text, *combo;
+	GtkWidget *hbox, *text, *drop_down;
+	GtkStringList *drop_down_options;
+	GtkExpression *expression;
 	struct oc_form_opt_select *sopt = (void *)data->opt;
 	int i, user_selection = -1;
 
 	hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
-	gtk_box_pack_start(GTK_BOX(data->ui_data->ssl_box), hbox, FALSE, FALSE, 0);
+	gtk_box_append(GTK_BOX(data->ui_data->ssl_box), hbox);
 
 	text = gtk_label_new(data->opt->label);
-	gtk_box_pack_start(GTK_BOX(hbox), text, FALSE, FALSE, 0);
+	gtk_box_append(GTK_BOX(hbox), text);
 
-	combo = gtk_combo_box_text_new();
-	gtk_box_pack_end(GTK_BOX(hbox), combo, FALSE, FALSE, 0);
+	drop_down_options = gtk_string_list_new(NULL);
+	expression = gtk_property_expression_new (GTK_TYPE_STRING_OBJECT,
+						  NULL,
+						  "string");
+
+	drop_down = gtk_drop_down_new(G_LIST_MODEL(drop_down_options),
+				      expression);
+	gtk_box_append(GTK_BOX(hbox), drop_down);
 
 	for (i = 0; i < sopt->nr_choices; i++) {
-		gtk_combo_box_text_append_text(GTK_COMBO_BOX_TEXT(combo), FORMCHOICE(sopt, i)->label);
+		gtk_string_list_append(drop_down_options, FORMCHOICE(sopt, i)->label);
 		if (data->entry_text &&
 		    !strcmp(data->entry_text, FORMCHOICE(sopt, i)->name))
 			user_selection = i;
@@ -423,17 +428,17 @@ static gboolean ui_add_select (ui_fragment_data *data)
 
 	i = data->initial_selection != -1 ? data->initial_selection :
 	    user_selection != -1 ? user_selection : 0;
-	gtk_combo_box_set_active(GTK_COMBO_BOX(combo), i);
+	gtk_drop_down_set_selected(GTK_DROP_DOWN(drop_down), i);
 	g_free(data->entry_text);
 	data->entry_text = FORMCHOICE(sopt, i)->name;
 	data->initial_selection = i;
 
 	if (g_queue_peek_tail(ui_data->form_entries) == data)
-		gtk_widget_grab_focus (combo);
-	g_signal_connect(G_OBJECT(combo), "changed", G_CALLBACK(combo_changed), data);
+		gtk_widget_grab_focus (drop_down);
+	g_signal_connect(G_OBJECT(drop_down), "changed", G_CALLBACK(drop_down_changed), data);
 	/* Hook up the 'show' signal to ensure that we override prompts on
 	   UI elements which may be coming later. */
-	g_signal_connect(G_OBJECT(combo), "show", G_CALLBACK(combo_changed), data);
+	g_signal_connect(G_OBJECT(drop_down), "show", G_CALLBACK(drop_down_changed), data);
 
 	/* data is freed in ui_flush in worker thread */
 
@@ -443,7 +448,7 @@ static gboolean ui_add_select (ui_fragment_data *data)
 static gboolean ui_show (auth_ui_data *ui_data)
 {
 	gtk_widget_hide (ui_data->getting_form_label);
-	gtk_widget_show_all (ui_data->ssl_box);
+	gtk_widget_show (ui_data->ssl_box);
 	gtk_widget_set_sensitive (ui_data->cancel_button, TRUE);
 	g_mutex_lock (&ui_data->form_mutex);
 	evaluate_login_visibility(ui_data);
@@ -465,12 +470,14 @@ static char *find_form_answer(GHashTable *secrets, struct oc_auth_form *form,
 	return result;
 }
 
+static void dialog_response (GtkDialog *dialog, int response, auth_ui_data *ui_data);
+
 static void form_autosubmit(auth_ui_data *ui_data)
 {
 	if (ui_data->fields_pending == 0 && ui_data->autosubmit) {
 		ui_data->autosubmit--;
-		gtk_button_clicked (GTK_BUTTON(ui_data->login_button));
 		gtk_widget_set_sensitive (ui_data->login_button, FALSE);
+		dialog_response (GTK_DIALOG(ui_data->dialog), AUTH_DIALOG_RESPONSE_LOGIN, ui_data);
 	}
 }
 
@@ -496,8 +503,8 @@ static void got_keyring_pw(GObject *object, GAsyncResult *result, gpointer userd
 	if (string != NULL) {
 		if (data->entry) {
 			if (!g_ascii_strcasecmp("",
-						gtk_entry_get_text(GTK_ENTRY(data->entry)))) {
-				gtk_entry_set_text(GTK_ENTRY(data->entry), string);
+						gtk_entry_buffer_get_text(gtk_entry_get_buffer(GTK_ENTRY(data->entry))))) {
+			gtk_entry_buffer_set_text(gtk_entry_get_buffer(GTK_ENTRY(data->entry)), string, -1);
 				if (gtk_widget_has_focus(data->entry))
 					gtk_editable_select_region(GTK_EDITABLE(data->entry), 0, -1);
 			}
@@ -662,7 +669,7 @@ static void load_changed_cb (WebKitWebView *web_view, WebKitLoadEvent load_event
 		return;
 	}
 
-	cm = webkit_web_context_get_cookie_manager(webkit_web_context_get_default());
+	cm = webkit_network_session_get_cookie_manager(webkit_web_view_get_network_session(web_view));
 	uri = webkit_web_view_get_uri(web_view);
 
 	webkit_cookie_manager_get_cookies(cm, uri, NULL, cookie_cb, ctx);
@@ -671,7 +678,7 @@ static void load_changed_cb (WebKitWebView *web_view, WebKitLoadEvent load_event
 static void cookie_cb (GObject *source_obj, GAsyncResult *res, gpointer data)
 {
 	struct WebviewContext *ctx = (struct WebviewContext *)data;
-	WebKitCookieManager *cm = webkit_web_context_get_cookie_manager(webkit_web_context_get_default());
+	WebKitCookieManager *cm = webkit_network_session_get_cookie_manager(webkit_web_view_get_network_session(ctx->webview));
 	WebKitWebResource *resource = NULL;
 	WebKitURIResponse *response = NULL;
 	SoupMessageHeaders *headers =  NULL;
@@ -743,16 +750,15 @@ static gboolean open_webview_idle(gpointer data)
 	struct WebviewContext *ctx = (struct WebviewContext *)data;
 	auth_ui_data *ui_data = _ui_data; /* FIXME global */
 	WebKitWebView *webView;
-	WebKitWebsiteDataManager *dm = NULL;
+	WebKitNetworkSession *ns = NULL;
 	WebKitCookieManager *cm = NULL;
 	GString *storage = NULL;
 
 	// Create a browser instance
 	webView = WEBKIT_WEB_VIEW(webkit_web_view_new());
-
-	dm = webkit_web_view_get_website_data_manager(webView);
-	if (dm)
-		cm = webkit_website_data_manager_get_cookie_manager(dm);
+	ns = webkit_web_view_get_network_session(webView);
+	if (ns)
+		cm = webkit_network_session_get_cookie_manager(ns);
 	if (cm)
 		storage = g_string_new (g_get_user_data_dir());
 	if (storage)
@@ -768,8 +774,7 @@ static gboolean open_webview_idle(gpointer data)
 
 	// Put the browser area into the main window
 	gtk_widget_set_size_request(GTK_WIDGET(webView), 640, 480);
-	gtk_box_pack_start(GTK_BOX(ui_data->ssl_box), GTK_WIDGET(webView), FALSE, FALSE, 0);
-	gtk_widget_show_all(ui_data->ssl_box);
+	gtk_box_append(GTK_BOX(ui_data->ssl_box), GTK_WIDGET(webView));
 
 	// Load a web page into the browser instance
 	webkit_web_view_load_uri(webView, ctx->login_uri);
@@ -806,17 +811,9 @@ static int open_webview(struct openconnect_info *vpninfo, const char *login_uri,
 
 static int open_uri(struct openconnect_info *vpninfo, const char *login_uri, void *privdata)
 {
-	GError *err = NULL;
-
 	G_GNUC_BEGIN_IGNORE_DEPRECATIONS
-	gtk_show_uri_on_window(NULL, login_uri, GDK_CURRENT_TIME, &err);
+	gtk_show_uri(NULL, login_uri, GDK_CURRENT_TIME);
 	G_GNUC_END_IGNORE_DEPRECATIONS
-	if (err) {
-		write_progress(NULL, PRG_ERR, "Failed to invoke GTK.show_uri_on_window.");
-		write_progress(NULL, PRG_ERR, "%s.", err->message);
-		g_error_free(err);
-		return 1;
-	}
 
 	return 0;
 }
@@ -946,6 +943,21 @@ static void cert_dialog_connect_clicked (GtkButton *btn, GtkDialog *dlg)
 	gtk_dialog_response(dlg, GTK_RESPONSE_OK);
 }
 
+static void cert_dialog_response(GtkDialog* dlg, gint result, gpointer user_data) {
+	auth_ui_data *ui_data = _ui_data; /* FIXME global */
+	cert_data *data = (cert_data *)user_data;
+
+	gtk_window_destroy(GTK_WINDOW(dlg));
+
+	g_mutex_lock (&ui_data->form_mutex);
+	if (result == GTK_RESPONSE_OK)
+		data->ui_data->cert_response = CERT_ACCEPTED;
+	else
+		data->ui_data->cert_response = CERT_DENIED;
+	g_cond_signal (&ui_data->cert_response_changed);
+	g_mutex_unlock (&ui_data->form_mutex);
+}
+
 static gboolean user_validate_cert(cert_data *data)
 {
 	auth_ui_data *ui_data = _ui_data; /* FIXME global */
@@ -964,14 +976,11 @@ static gboolean user_validate_cert(cert_data *data)
 	unsigned char *der_cert;
 	int der_cert_size;
 	GcrCertificate *cert;
-	GcrCertificateWidget *cert_widget;
 
 	GtkWidget *cancel_button;
 	GtkWidget *security_expander;
 	GtkWidget *connect_button;
 
-	int result;
-
 	title = get_title(data->ui_data->vpn_name);
 	dlg = gtk_dialog_new();
 	gtk_window_set_modal(GTK_WINDOW(dlg), true);
@@ -980,35 +989,28 @@ static gboolean user_validate_cert(cert_data *data)
 	g_free(title);
 
 	vbox = gtk_box_new(GTK_ORIENTATION_VERTICAL, 8);
-	gtk_box_pack_start(GTK_BOX (gtk_dialog_get_content_area(GTK_DIALOG (dlg))), vbox, TRUE, TRUE, 0);
-	gtk_container_set_border_width(GTK_CONTAINER(vbox), 8);
-	gtk_widget_show(vbox);
+	gtk_box_append(GTK_BOX (gtk_dialog_get_content_area(GTK_DIALOG (dlg))), vbox);
+	gtk_box_set_spacing(GTK_BOX(vbox), 8);
 
 	warning_label_text = g_strconcat(_("<b>The certificate may be invalid or untrusted!</b>\n"),
 									 _("<b>Reason: "), data->reason, ".</b>",
 									 NULL);
 	warning_label = gtk_label_new(NULL);
 	gtk_label_set_markup(GTK_LABEL(warning_label), warning_label_text);
-	gtk_box_pack_start(GTK_BOX(vbox), GTK_WIDGET(warning_label), FALSE, FALSE, 0);
+	gtk_box_append(GTK_BOX(vbox), GTK_WIDGET(warning_label));
 	gtk_widget_set_halign(warning_label, GTK_ALIGN_START);
-	gtk_label_set_line_wrap(GTK_LABEL(warning_label), true);
-	gtk_widget_show(warning_label);
+	gtk_label_set_wrap(GTK_LABEL(warning_label), true);
 	g_free(warning_label_text);
 
 	der_cert_size = openconnect_get_peer_cert_DER(data->ui_data->vpninfo, &der_cert);
 	cert = gcr_simple_certificate_new_static(der_cert, der_cert_size);
-	cert_widget = gcr_certificate_widget_new(cert);
-	gtk_box_pack_start(GTK_BOX(vbox), GTK_WIDGET(cert_widget), FALSE, FALSE, 0);
-	gtk_widget_show(GTK_WIDGET(cert_widget));
 
 	hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 4);
-	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
-	gtk_widget_show(hbox);
+	gtk_box_append(GTK_BOX(vbox), hbox);
 
 	cancel_button = gtk_button_new_with_mnemonic(_("_Cancel"));
-	gtk_box_pack_start(GTK_BOX(hbox), cancel_button, FALSE, FALSE, 0);
+	gtk_box_append(GTK_BOX(hbox), cancel_button);
 	g_signal_connect(cancel_button, "clicked", G_CALLBACK(cert_dialog_cancel_clicked), dlg);
-	gtk_widget_show(cancel_button);
 
 	prevent_invalid_cert = g_hash_table_lookup(ui_data->options,
 							NM_OPENCONNECT_KEY_PREVENT_INVALID_CERT);
@@ -1016,34 +1018,21 @@ static gboolean user_validate_cert(cert_data *data)
 
 	if (invalid_cert_allowed) {
 		security_expander = gtk_expander_new(_("I really know what I am doing"));
-		gtk_box_pack_start(GTK_BOX(vbox), security_expander, FALSE, FALSE, 0);
-		gtk_widget_show(security_expander);
+		gtk_box_append(GTK_BOX(vbox), security_expander);
 
 		expander_hbox = gtk_box_new(GTK_ORIENTATION_HORIZONTAL, 0);
-		gtk_container_add(GTK_CONTAINER(security_expander), expander_hbox);
-		gtk_container_set_border_width(GTK_CONTAINER(expander_hbox), 0);
-		gtk_widget_show(expander_hbox);
+		gtk_expander_set_child(GTK_EXPANDER(security_expander), expander_hbox);
+		gtk_box_set_spacing(GTK_BOX(expander_hbox), 0);
 
 		connect_button = gtk_button_new_with_label(_("Connect anyway"));
-		gtk_box_pack_start(GTK_BOX(expander_hbox), connect_button, FALSE, FALSE, 0);
+		gtk_box_append(GTK_BOX(expander_hbox), connect_button);
 		gtk_widget_set_margin_start(connect_button, 12);
 		gtk_widget_set_margin_top(connect_button, 8);
 		g_signal_connect(connect_button, "clicked", G_CALLBACK(cert_dialog_connect_clicked), dlg);
-		gtk_widget_show(connect_button);
 	}
 
-	result = gtk_dialog_run(GTK_DIALOG(dlg));
-
-	gtk_widget_destroy(dlg);
-
-	g_mutex_lock (&ui_data->form_mutex);
-	if (result == GTK_RESPONSE_OK)
-		data->ui_data->cert_response = CERT_ACCEPTED;
-	else
-		data->ui_data->cert_response = CERT_DENIED;
-	g_cond_signal (&ui_data->cert_response_changed);
-	g_mutex_unlock (&ui_data->form_mutex);
-
+	gtk_window_set_modal(GTK_WINDOW(dlg), GTK_DIALOG_MODAL);
+	g_signal_connect(dlg, "response", G_CALLBACK(cert_dialog_response), data);
 	return FALSE;
 }
 
@@ -1361,18 +1350,19 @@ static int get_config (auth_ui_data *ui_data,
 	return 0;
 }
 
-static void populate_vpnhost_combo(auth_ui_data *ui_data)
+static void populate_vpnhost_drop_down(auth_ui_data *ui_data)
 {
 	struct vpnhost *host;
 	int i = 0;
-	GtkComboBoxText *combo = GTK_COMBO_BOX_TEXT (ui_data->combo);
+	GtkDropDown *drop_down = GTK_DROP_DOWN (ui_data->drop_down);
+	GtkStringList *list = GTK_STRING_LIST(gtk_drop_down_get_model(drop_down));
 
 	for (host = vpnhosts; host; host = host->next) {
-		gtk_combo_box_text_append_text(combo, host->hostname);
+		gtk_string_list_append(list, host->hostname);
 
 		if (i == 0 ||
 		    (lasthost && !strcmp(host->hostname, lasthost)))
-			gtk_combo_box_set_active(GTK_COMBO_BOX (combo), i);
+			gtk_drop_down_set_selected(GTK_DROP_DOWN (drop_down), i);
 		i++;
 
 	}
@@ -1577,9 +1567,7 @@ static gboolean cookie_obtained(auth_ui_data *ui_data)
 		/* error while getting cookie */
 		if (ui_data->last_notice_icon) {
 			gtk_image_set_from_icon_name(GTK_IMAGE (ui_data->last_notice_icon),
-						     "dialog-error",
-						     GTK_ICON_SIZE_DIALOG);
-			gtk_widget_show_all(ui_data->ssl_box);
+						     "dialog-error");
 			gtk_widget_set_sensitive(ui_data->cancel_button, FALSE);
 		}
 	} else if (!ui_data->cookie_retval) {
@@ -1631,7 +1619,7 @@ static gboolean cookie_obtained(auth_ui_data *ui_data)
 					     NULL);
 		}
 
-		gtk_main_quit();
+		g_application_quit(G_APPLICATION(ui_data->application));
 	} else {
 		/* no cookie; user cancellation */
 		gtk_widget_show (ui_data->no_form_label);
@@ -1675,7 +1663,6 @@ static void connect_host(auth_ui_data *ui_data)
 	g_mutex_unlock (&ui_data->form_mutex);
 
 	ssl_box_clear(ui_data);
-	gtk_widget_show(ui_data->getting_form_label);
 	gtk_widget_set_sensitive (ui_data->cancel_button, TRUE);
 	while (read(ui_data->cancel_pipes[0], &cancelbuf, 1) == 1)
 		;
@@ -1683,7 +1670,7 @@ static void connect_host(auth_ui_data *ui_data)
 	 * TODO: this is probably not the way to go... */
 	openconnect_reset_ssl(ui_data->vpninfo);
 
-	host_nr = gtk_combo_box_get_active(GTK_COMBO_BOX(ui_data->combo));
+	host_nr = gtk_drop_down_get_selected(GTK_DROP_DOWN(ui_data->drop_down));
 	host = vpnhosts;
 	for (i = 0; i < host_nr; i++)
 		host = host->next;
@@ -1741,7 +1728,7 @@ static void dialog_response (GtkDialog *dialog, int response, auth_ui_data *ui_d
 		g_mutex_unlock (&ui_data->form_mutex);
 		break;
 	case GTK_RESPONSE_CLOSE:
-		gtk_main_quit();
+		g_application_quit(G_APPLICATION(ui_data->application));
 		break;
 	default:
 		;
@@ -1763,6 +1750,8 @@ static void build_main_dialog(auth_ui_data *ui_data)
 	char *title;
 	GtkWidget *vbox, *hbox, *label, *frame, *frame_box;
 	GtkWidget *exp, *scrolled, *view, *autocon, *save_pass;
+	GtkStringList *drop_down_options;
+	GtkExpression *expression;
 
 	gtk_window_set_default_icon_name("dialog-password");
 
@@ -1773,102 +1762,92 @@ static void build_main_dialog(auth_ui_data *ui_data)
 	g_signal_connect (ui_data->dialog, "response", G_CALLBACK(dialog_response), ui_data);
 	gtk_window_set_default_size(GTK_WINDOW(ui_data->dialog), 350, 300);
 	g_signal_connect_swapped(ui_data->dialog, "destroy",
-				 G_CALLBACK(gtk_main_quit), NULL);
+				 G_CALLBACK(g_application_quit), ui_data->application);
 	g_free(title);
 
 	vbox = gtk_box_new (GTK_ORIENTATION_VERTICAL, 8);
-	gtk_box_pack_start(GTK_BOX (gtk_dialog_get_content_area(GTK_DIALOG (ui_data->dialog))), vbox, TRUE, TRUE, 0);
-	gtk_container_set_border_width(GTK_CONTAINER(vbox), 8);
-	gtk_widget_show(vbox);
+	gtk_box_append(GTK_BOX (gtk_dialog_get_content_area(GTK_DIALOG (ui_data->dialog))), vbox);
+	gtk_box_set_spacing(GTK_BOX(vbox), 8);
 
 	hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 4);
-	gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 0);
-	gtk_widget_show(hbox);
+	gtk_box_append(GTK_BOX(vbox), hbox);
 
 	label = gtk_label_new(_("VPN host"));
-	gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
-	gtk_widget_show(label);
+	gtk_box_append(GTK_BOX(hbox), label);
 
-	ui_data->combo = gtk_combo_box_text_new();
-	populate_vpnhost_combo(ui_data);
-	gtk_box_pack_start(GTK_BOX(hbox), ui_data->combo, TRUE, TRUE, 0);
-	g_signal_connect_swapped(ui_data->combo, "changed",
-	                         G_CALLBACK(queue_connect_host), ui_data);
-	gtk_widget_show(ui_data->combo);
+	drop_down_options = gtk_string_list_new(NULL);
+	expression = gtk_property_expression_new (GTK_TYPE_STRING_OBJECT,
+						  NULL,
+						  "string");
+
+	ui_data->drop_down = gtk_drop_down_new(drop_down_options, expression);
+	populate_vpnhost_drop_down(ui_data);
+	gtk_box_append(GTK_BOX(hbox), ui_data->drop_down);
+	g_signal_connect_swapped(ui_data->drop_down, "changed",
+				 G_CALLBACK(queue_connect_host), ui_data);
 
 	ui_data->connect_button = gtk_button_new_with_mnemonic(_("C_onnect"));
-	gtk_box_pack_end(GTK_BOX(hbox), ui_data->connect_button, FALSE, FALSE, 0);
+	gtk_box_append(GTK_BOX(hbox), ui_data->connect_button);
 	gtk_widget_grab_focus(ui_data->connect_button);
 	g_signal_connect_swapped(ui_data->connect_button, "clicked",
 				 G_CALLBACK(queue_connect_host), ui_data);
-	gtk_widget_show(ui_data->connect_button);
 	if (vpnhosts->next) {
 		autocon = gtk_check_button_new_with_label(_("Automatically start connecting next time"));
-		gtk_box_pack_start(GTK_BOX(vbox), autocon, FALSE, FALSE, 0);
+		gtk_box_append(GTK_BOX(vbox), autocon);
 		if (get_autoconnect (ui_data->secrets))
 			gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(autocon), 1);
 		g_signal_connect(autocon, "toggled", G_CALLBACK(autocon_toggled), NULL);
-		gtk_widget_show(autocon);
 		ui_data->autoconnect = autocon;
 	}
 
 	frame = gtk_frame_new(NULL);
-	gtk_box_pack_start(GTK_BOX(vbox), frame, TRUE, TRUE, 0);
+	gtk_box_append(GTK_BOX(vbox), frame);
 	gtk_widget_set_size_request(frame, -1, -1);
-	gtk_widget_show(frame);
 
 	frame_box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 4);
-	gtk_container_set_border_width(GTK_CONTAINER(frame_box), 8);
-	gtk_container_add(GTK_CONTAINER(frame), frame_box);
-	gtk_widget_show(frame_box);
+	gtk_box_set_spacing(GTK_BOX(frame_box), 8);
+	gtk_frame_set_child(frame, frame_box);
 
 	ui_data->no_form_label = gtk_label_new(_("Select a host to fetch the login form"));
 	gtk_widget_set_sensitive(ui_data->no_form_label, FALSE);
-	gtk_box_pack_start(GTK_BOX(frame_box), ui_data->no_form_label, FALSE, FALSE, 0);
-	gtk_widget_show(ui_data->no_form_label);
+	gtk_box_append(GTK_BOX(frame_box), ui_data->no_form_label);
 
 	ui_data->getting_form_label = gtk_label_new(_("Contacting host, please waitâ€¦"));
+	gtk_widget_hide(ui_data->getting_form_label);
 	gtk_widget_set_sensitive(ui_data->getting_form_label, FALSE);
-	gtk_box_pack_start(GTK_BOX(frame_box), ui_data->getting_form_label, FALSE, FALSE, 0);
+	gtk_box_append(GTK_BOX(frame_box), ui_data->getting_form_label);
 
 	ui_data->ssl_box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 4);
-	gtk_box_pack_start(GTK_BOX(frame_box), ui_data->ssl_box, FALSE, FALSE, 0);
-	gtk_widget_show(ui_data->ssl_box);
+	gtk_box_append(GTK_BOX(frame_box), ui_data->ssl_box);
 
 	hbox = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 6);
-	gtk_box_pack_end(GTK_BOX(frame_box), hbox, FALSE, FALSE, 0);
-	gtk_widget_show(hbox);
+	gtk_box_append(GTK_BOX(frame_box), hbox);
 
 	ui_data->login_button = gtk_button_new_with_mnemonic(_("_Login"));
-	gtk_box_pack_end(GTK_BOX(hbox), ui_data->login_button, FALSE, FALSE, 0);
+	gtk_box_append(GTK_BOX(hbox), ui_data->login_button);
 	g_signal_connect (ui_data->login_button, "clicked", G_CALLBACK(login_clicked), ui_data);
 	gtk_widget_set_sensitive (ui_data->login_button, FALSE);
-	gtk_widget_show(ui_data->login_button);
 
 	ui_data->cancel_button = gtk_button_new_with_mnemonic(_("_Cancel"));
-	gtk_box_pack_end(GTK_BOX(hbox), ui_data->cancel_button, FALSE, FALSE, 0);
+	gtk_box_append(GTK_BOX(hbox), ui_data->cancel_button);
 	g_signal_connect (ui_data->cancel_button, "clicked", G_CALLBACK(cancel_clicked), ui_data);
 	gtk_widget_set_sensitive (ui_data->cancel_button, FALSE);
-	gtk_widget_show(ui_data->cancel_button);
 
 	save_pass = gtk_check_button_new_with_label(_("Save passwords"));
-	gtk_box_pack_start(GTK_BOX(hbox), save_pass, FALSE, FALSE, 0);
+	gtk_box_append(GTK_BOX(hbox), save_pass);
 	if (get_save_passwords (ui_data->secrets))
 		gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(save_pass), 1);
 	g_signal_connect(save_pass, "toggled", G_CALLBACK(savepass_toggled), NULL);
-	gtk_widget_show(save_pass);
 
 
 	exp = gtk_expander_new(_("Log"));
-	gtk_box_pack_end(GTK_BOX(vbox), exp, FALSE, FALSE, 0);
-	gtk_widget_show(exp);
+	gtk_box_append(GTK_BOX(vbox), exp);
 
-	scrolled = gtk_scrolled_window_new(NULL, NULL);
+	scrolled = gtk_scrolled_window_new();
 	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolled),
 				       GTK_POLICY_NEVER, GTK_POLICY_AUTOMATIC);
 	gtk_widget_set_size_request(scrolled, -1, 75);
-	gtk_container_add(GTK_CONTAINER(exp), scrolled);
-	gtk_widget_show(scrolled);
+	gtk_expander_set_child(GTK_EXPANDER(exp), scrolled);
 
 	view = gtk_text_view_new();
 	gtk_text_view_set_editable(GTK_TEXT_VIEW(view), FALSE);
@@ -1877,8 +1856,7 @@ static void build_main_dialog(auth_ui_data *ui_data)
 	gtk_text_view_set_left_margin(GTK_TEXT_VIEW(view), 5);
 	gtk_text_view_set_right_margin(GTK_TEXT_VIEW(view), 5);
 	gtk_text_view_set_indent(GTK_TEXT_VIEW(view), -10);
-	gtk_container_add(GTK_CONTAINER(scrolled), view);
-	gtk_widget_show(view);
+	gtk_scrolled_window_set_child(GTK_SCROLLED_WINDOW(scrolled), view);
 
 	ui_data->log = gtk_text_view_get_buffer(GTK_TEXT_VIEW(view));
 	g_signal_connect(ui_data->log, "changed", G_CALLBACK(scroll_log), view);
@@ -1968,7 +1946,7 @@ static gpointer init_connection (auth_ui_data *ui_data)
 	if (ui_data->token_mode != OC_TOKEN_MODE_NONE)
 		__openconnect_set_token_mode(ui_data->vpninfo, ui_data->token_mode, ui_data->token_secret);
 
-	gtk_widget_set_sensitive (ui_data->combo, TRUE);
+	gtk_widget_set_sensitive (ui_data->drop_down, TRUE);
 	gtk_widget_set_sensitive (ui_data->connect_button, TRUE);
 
 	/* Start connecting now if there's only one host. Or if configured to */
@@ -1998,7 +1976,7 @@ static gboolean process_stdin (GIOChannel *source, GIOCondition condition, auth_
 				ui_data->quit_seen = TRUE;
 				/* Only really quit when called properly from the main loop. */
 				if (condition)
-					gtk_main_quit();
+					g_application_quit(G_APPLICATION(ui_data->application));
 			}
 			g_string_truncate(ui_data->stdin_line, 0);
 			continue;
@@ -2009,6 +1987,22 @@ static gboolean process_stdin (GIOChannel *source, GIOCondition condition, auth_
 	}
 }
 
+static void on_activate (GtkApplication *application) {
+#if OPENCONNECT_CHECK_VER(3,4)
+	openconnect_set_token_callbacks (_ui_data->vpninfo, _ui_data, NULL, update_token);
+#endif
+
+	build_main_dialog(_ui_data);
+
+	/* These can't be done until token password handled */
+	gtk_widget_set_sensitive (_ui_data->drop_down, FALSE);
+	gtk_widget_set_sensitive (_ui_data->connect_button, FALSE);
+
+	gtk_window_present(GTK_WINDOW(_ui_data->dialog));
+
+	gtk_application_add_window(application, GTK_WINDOW(_ui_data->dialog));
+}
+
 int main (int argc, char **argv)
 {
 	char *vpn_name = NULL, *vpn_uuid = NULL, *vpn_service = NULL;
@@ -2078,7 +2072,7 @@ int main (int argc, char **argv)
 		return 1;
 	}
 
-	gtk_init(0, NULL);
+	gtk_init();
 
 	_ui_data = init_ui_data(vpn_name, options, secrets, vpn_uuid);
 	if (get_config(_ui_data, options, secrets)) {
@@ -2092,6 +2086,7 @@ int main (int argc, char **argv)
 	_ui_data->stdin_source = g_io_create_watch(_ui_data->stdin_channel, G_IO_IN);
 	_ui_data->stdin_line = g_string_new("");
 
+	_ui_data->application = gtk_application_new(NULL, G_APPLICATION_FLAGS_NONE);
 	/*
 	 * https://gitlab.gnome.org/GNOME/network-manager-applet/-/issues/179
 	 *
@@ -2108,25 +2103,13 @@ int main (int argc, char **argv)
 	}
 
 	if (allow_interaction) {
-#if OPENCONNECT_CHECK_VER(3,4)
-		openconnect_set_token_callbacks (_ui_data->vpninfo, _ui_data, NULL, update_token);
-#endif
-
-		build_main_dialog(_ui_data);
-
 		openconnect_init_ssl();
-
-		/* These can't be done until token password handled */
-		gtk_widget_set_sensitive (_ui_data->combo, FALSE);
-		gtk_widget_set_sensitive (_ui_data->connect_button, FALSE);
-
 		init_thread = g_thread_new("init_connection", (GThreadFunc)init_connection, _ui_data);
 		g_thread_unref(init_thread);
 
-		gtk_window_present(GTK_WINDOW(_ui_data->dialog));
-		gtk_main();
+		g_signal_connect (_ui_data->application, "activate", G_CALLBACK (on_activate), NULL);
+		g_application_run(G_APPLICATION(_ui_data->application), 0, NULL);
 	}
-
 	/* Dump all secrets to stdout */
 	if (g_hash_table_size (_ui_data->secrets) > 0) {
 		g_hash_table_iter_init (&iter, _ui_data->secrets);
@@ -2138,7 +2121,7 @@ int main (int argc, char **argv)
 	fflush(paramf);
 
 	if (!_ui_data->quit_seen)
-		gtk_main();
+		g_application_run(G_APPLICATION(_ui_data->application), 0, NULL);
 
 	return 0;
 }
diff --git a/configure.ac b/configure.ac
index 49ad700..56fea74 100644
--- a/configure.ac
+++ b/configure.ac
@@ -113,19 +113,21 @@ GLIB_CFLAGS="$GLIB_CFLAGS -DGLIB_VERSION_MAX_ALLOWED=GLIB_VERSION_2_34"
 PKG_CHECK_MODULES(GMODULE, gmodule-2.0)
 PKG_CHECK_MODULES(LIBXML, libxml-2.0)
 
-if test x"$with_gnome" != xno || test x"$with_gtk4" != xno; then
+if test x"$with_gnome" != xno && test x"$with_gtk4" != xno; then
 	PKG_CHECK_MODULES(LIBSECRET, libsecret-1 >= 0.18)
-fi
+	PKG_CHECK_MODULES(GCR, gcr-4 >= 4.0)
+	GCR_CFLAGS="$GCR_CFLAGS -DGCR_API_SUBJECT_TO_CHANGE"
 
-if test x"$with_gnome" != xno; then
-	PKG_CHECK_MODULES(GTK, gtk+-3.0 >= 3.12)
-	GTK_CFLAGS="$GTK_CFLAGS -DGDK_VERSION_MIN_REQUIRED=GDK_VERSION_3_12"
-	GTK_CFLAGS="$GTK_CFLAGS -DGDK_VERSION_MAX_ALLOWED=GDK_VERSION_3_12"
-	PKG_CHECK_MODULES(LIBNMA, libnma >= 1.2.0)
+fi
 
-	PKG_CHECK_MODULES(GCR, gcr-3 >= 3.4)
-	GCR_CFLAGS="$GCR_CFLAGS -DGCR_API_SUBJECT_TO_CHANGE"
+if test x"$with_gtk4" != xno; then
+	PKG_CHECK_MODULES(GTK4, gtk4 >= 4.0)
+	GTK4_CFLAGS="$GTK4_CFLAGS -DGDK_VERSION_MIN_REQUIRED=GDK_VERSION_4_0"
+	GTK4_CFLAGS="$GTK4_CFLAGS -DGDK_VERSION_MAX_ALLOWED=GDK_VERSION_4_0"
+	PKG_CHECK_MODULES(LIBNMA_GTK4, libnma-gtk4 >= 1.8.33)
+fi
 
+if test x"$with_gnome" != xno; then
 	if test x"$with_libnm_glib" != xno; then
 		PKG_CHECK_MODULES(LIBNM_GLIB,
 			NetworkManager >= 1.2.0
@@ -138,13 +140,6 @@ if test x"$with_gnome" != xno; then
 	fi
 fi
 
-if test x"$with_gtk4" != xno; then
-	PKG_CHECK_MODULES(GTK4, gtk4 >= 4.0)
-	GTK4_CFLAGS="$GTK4_CFLAGS -DGDK_VERSION_MIN_REQUIRED=GDK_VERSION_4_0"
-	GTK4_CFLAGS="$GTK4_CFLAGS -DGDK_VERSION_MAX_ALLOWED=GDK_VERSION_4_0"
-	PKG_CHECK_MODULES(LIBNMA_GTK4, libnma-gtk4 >= 1.8.33)
-fi
-
 PKG_CHECK_MODULES(LIBNM, libnm >= 1.2.0)
 LIBNM_CFLAGS="$LIBNM_CFLAGS -DNM_VERSION_MIN_REQUIRED=NM_VERSION_1_2"
 LIBNM_CFLAGS="$LIBNM_CFLAGS -DNM_VERSION_MAX_ALLOWED=NM_VERSION_1_4"
@@ -157,14 +152,17 @@ else
 		if test x"$with_gnome" == xno; then
 			AC_MSG_ERROR(Building --with-authdlg requires --with-gnome)
 		fi
+		if test x"$with_gtk4" == xno; then
+			AC_MSG_ERROR(Building --with-authdlg requires --with-gtk4)
+		fi
 		with_authdlg=yes
 	fi
 fi
+
+PKG_CHECK_MODULES(OPENCONNECT, openconnect >= 3.02)
 if test x"$with_authdlg" != xno; then
-	PKG_CHECK_MODULES(OPENCONNECT, openconnect >= 3.02)
-	PKG_CHECK_MODULES(WEBKIT, webkit2gtk-4.1, [wekbit=4.1],
-				  [PKG_CHECK_MODULES(WEBKIT, webkit2gtk-4.0,
-				  [webkit=4.0], AC_MSG_ERROR(Neither webkit2gtk-4.0 nor wekit2gtk-4.1 found))])
+	PKG_CHECK_MODULES(WEBKIT, webkitgtk-6.0, [wekbit=6.0],
+				  AC_MSG_ERROR(webkitgtk-6.0 not found))
 fi
 AM_CONDITIONAL(WITH_AUTHDLG, test x"$with_authdlg" != xno)
 
-- 
2.52.0

