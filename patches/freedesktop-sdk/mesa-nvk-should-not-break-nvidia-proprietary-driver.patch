diff --git a/elements/extensions/mesa/mesa-sources.yml b/elements/extensions/mesa/mesa-sources.yml
index 91843973c..855c27ec1 100644
--- a/elements/extensions/mesa/mesa-sources.yml
+++ b/elements/extensions/mesa/mesa-sources.yml
@@ -8,6 +8,8 @@ sources:
   ref: mesa-24.1.2-0-g414057c05c3dff39674ad45855858af02e995c2b
 - kind: patch
   path: patches/mesa/clang_res_path.patch
+- kind: patch
+  path: patches/mesa/nvk-should-not-break-nvidia-proprietary-driver.patch
 # Rust dependencies:
 - kind: tar
   directory: subprojects/packagecache/syn-2.0.39
diff --git a/patches/mesa/nvk-should-not-break-nvidia-proprietary-driver.patch b/patches/mesa/nvk-should-not-break-nvidia-proprietary-driver.patch
new file mode 100644
index 000000000..210a6e4ab
--- /dev/null
+++ b/patches/mesa/nvk-should-not-break-nvidia-proprietary-driver.patch
@@ -0,0 +1,63 @@
+From 615eb1a34deccc39ccb5d646d2daf1640d4c28ac Mon Sep 17 00:00:00 2001
+From: Faith Ekstrand <faith.ekstrand@collabora.com>
+Date: Wed, 3 Jul 2024 23:26:11 -0500
+Subject: [PATCH] nvk: Silently fail to enumerate if not on nouveau
+
+The NVIDIA proprietary driver exposes a DRM device these days and this
+can trip up NVK as it advertises an NVIDIA device id.  We fail to
+enumerate but the check for nouveau happens too late and we throw a
+warning.  This means tha if NVK is even installed side-by-side with the
+proprietary driver, we spam warnings on every device enumeration.  It's
+better to fail silently.
+
+Fixes: 83786bf1c9c1 ("nvk: add vulkan skeleton")
+Closes: https://gitlab.freedesktop.org/mesa/mesa/-/issues/11441
+Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/30035>
+---
+ src/nouveau/vulkan/nvk_physical_device.c | 24 ++++++++++++++++++++++++
+ 1 file changed, 24 insertions(+)
+
+diff --git a/src/nouveau/vulkan/nvk_physical_device.c b/src/nouveau/vulkan/nvk_physical_device.c
+index 23837ff9e59..97fe1ba4150 100644
+--- a/src/nouveau/vulkan/nvk_physical_device.c
++++ b/src/nouveau/vulkan/nvk_physical_device.c
+@@ -1068,6 +1068,27 @@ nvk_get_vram_heap_available(struct nvk_physical_device *pdev)
+    return pdev->info.vram_size_B - used;
+ }
+ 
++static bool
++drm_device_is_nouveau(const char *path)
++{
++   int fd = open(path, O_RDWR | O_CLOEXEC);
++   if (fd < 0)
++      return false;
++
++   drmVersionPtr ver = drmGetVersion(fd);
++   if (!ver) {
++      close(fd);
++      return false;
++   }
++
++   const bool is_nouveau = !strncmp("nouveau", ver->name, ver->name_len);
++
++   drmFreeVersion(ver);
++   close(fd);
++
++   return is_nouveau;
++}
++
+ VkResult
+ nvk_create_drm_physical_device(struct vk_instance *_instance,
+                                drmDevicePtr drm_device,
+@@ -1104,6 +1125,9 @@ nvk_create_drm_physical_device(struct vk_instance *_instance,
+       return VK_ERROR_INCOMPATIBLE_DRIVER;
+    }
+ 
++   if (!drm_device_is_nouveau(drm_device->nodes[DRM_NODE_RENDER]))
++      return VK_ERROR_INCOMPATIBLE_DRIVER;
++
+    struct nouveau_ws_device *ws_dev = nouveau_ws_device_new(drm_device);
+    if (!ws_dev)
+       return vk_error(instance, VK_ERROR_INCOMPATIBLE_DRIVER);
+-- 
+2.45.2
