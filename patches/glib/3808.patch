From d2e6892996465eae7e976222ad3454e6fe138979 Mon Sep 17 00:00:00 2001
From: Jordan Petridis <jordan@centricular.com>
Date: Mon, 8 Jan 2024 11:05:25 +0200
Subject: [PATCH] glib/deprecated: Skip all the deprecated gthread api

Previously, the girs and typelibs generated from gobject-introspection
ommited the deprecated apis, however we want them annotated for
documentation purposes.

Skip the deprecated gthead api so they do not make it into the
typelibs which caused problems as not all the symbols exist.

See https://gitlab.gnome.org/GNOME/gjs/-/issues/595
---
 glib/deprecated/gthread-deprecated.c | 102 ++++++++++++++-------------
 1 file changed, 53 insertions(+), 49 deletions(-)

diff --git a/glib/deprecated/gthread-deprecated.c b/glib/deprecated/gthread-deprecated.c
index ec0f1a7f38..fb281ac517 100644
--- a/glib/deprecated/gthread-deprecated.c
+++ b/glib/deprecated/gthread-deprecated.c
@@ -41,7 +41,7 @@
 /* {{{1 Documentation */
 
 /**
- * GThreadPriority:
+ * GThreadPriority: (skip):
  * @G_THREAD_PRIORITY_LOW: a priority lower than normal
  * @G_THREAD_PRIORITY_NORMAL: the default priority
  * @G_THREAD_PRIORITY_HIGH: a priority higher than normal
@@ -53,7 +53,7 @@
  */
 
 /**
- * GThreadFunctions:
+ * GThreadFunctions: (skip):
  * @mutex_new: virtual function pointer for g_mutex_new()
  * @mutex_lock: virtual function pointer for g_mutex_lock()
  * @mutex_trylock: virtual function pointer for g_mutex_trylock()
@@ -83,7 +83,7 @@
  */
 
 /**
- * G_THREADS_IMPL_POSIX:
+ * G_THREADS_IMPL_POSIX: (skip):
  *
  * This macro is defined if POSIX style threads are used.
  *
@@ -92,7 +92,7 @@
  */
 
 /**
- * G_THREADS_IMPL_WIN32:
+ * G_THREADS_IMPL_WIN32: (skip):
  *
  * This macro is defined if Windows style threads are used.
  *
@@ -144,7 +144,7 @@ guint64 (*g_thread_gettime) (void) = gettime;
 gboolean         g_threads_got_initialized = TRUE;
 
 /**
- * g_thread_init:
+ * g_thread_init: (skip):
  * @vtable: a function table of type #GThreadFunctions, that provides
  *     the entry points to the thread system to be used. Since 2.32,
  *     this parameter is ignored and should always be %NULL
@@ -174,7 +174,11 @@ gboolean         g_threads_got_initialized = TRUE;
  */
 
 /**
- * g_thread_get_initialized:
+ * g_thread_init_with_errorcheck_mutexes: (skip):
+ */
+
+/**
+ * g_thread_get_initialized: (skip):
  *
  * Indicates if g_thread_init() has been called.
  *
@@ -205,7 +209,7 @@ G_LOCK_DEFINE_STATIC (g_thread);
 /* Misc. GThread functions {{{1 */
 
 /**
- * g_thread_set_priority:
+ * g_thread_set_priority: (skip):
  * @thread: a #GThread.
  * @priority: ignored
  *
@@ -220,7 +224,7 @@ g_thread_set_priority (GThread         *thread,
 }
 
 /**
- * g_thread_foreach:
+ * g_thread_foreach: (skip):
  * @thread_func: (scope call): function to call for all #GThread structures
  * @user_data: second argument to @thread_func
  *
@@ -304,7 +308,7 @@ g_deprecated_thread_proxy (gpointer data)
 }
 
 /**
- * g_thread_create:
+ * g_thread_create: (skip):
  * @func: a function to execute in the new thread
  * @data: an argument to supply to the new thread
  * @joinable: should this thread be joinable?
@@ -337,7 +341,7 @@ g_thread_create (GThreadFunc   func,
 }
 
 /**
- * g_thread_create_full:
+ * g_thread_create_full: (skip):
  * @func: a function to execute in the new thread.
  * @data: an argument to supply to the new thread.
  * @stack_size: a stack size for the new thread.
@@ -386,7 +390,7 @@ g_once_init_enter_impl (volatile gsize *location)
 /* GStaticMutex {{{1 ------------------------------------------------------ */
 
 /**
- * GStaticMutex:
+ * GStaticMutex: (skip):
  *
  * A #GStaticMutex works like a #GMutex.
  *
@@ -437,7 +441,7 @@ g_once_init_enter_impl (volatile gsize *location)
  */
 
 /**
- * G_STATIC_MUTEX_INIT:
+ * G_STATIC_MUTEX_INIT: (skip):
  *
  * A #GStaticMutex must be initialized with this macro, before it can
  * be used. This macro can used be to initialize a variable, but it
@@ -450,7 +454,7 @@ g_once_init_enter_impl (volatile gsize *location)
  **/
 
 /**
- * g_static_mutex_init:
+ * g_static_mutex_init: (skip):
  * @mutex: a #GStaticMutex to be initialized.
  *
  * Initializes @mutex.
@@ -486,7 +490,7 @@ g_static_mutex_init (GStaticMutex *mutex)
  */
 
 /**
- * g_static_mutex_get_mutex:
+ * g_static_mutex_get_mutex: (skip):
  * @mutex: a #GStaticMutex.
  *
  * For some operations (like g_cond_wait()) you must have a #GMutex
@@ -533,7 +537,7 @@ g_static_mutex_get_mutex_impl (GStaticMutex* mutex)
  */
 
 /**
- * g_static_mutex_lock:
+ * g_static_mutex_lock: (skip):
  * @mutex: a #GStaticMutex.
  *
  * Works like g_mutex_lock(), but for a #GStaticMutex.
@@ -542,7 +546,7 @@ g_static_mutex_get_mutex_impl (GStaticMutex* mutex)
  */
 
 /**
- * g_static_mutex_trylock:
+ * g_static_mutex_trylock: (skip):
  * @mutex: a #GStaticMutex.
  *
  * Works like g_mutex_trylock(), but for a #GStaticMutex.
@@ -553,7 +557,7 @@ g_static_mutex_get_mutex_impl (GStaticMutex* mutex)
  */
 
 /**
- * g_static_mutex_unlock:
+ * g_static_mutex_unlock: (skip):
  * @mutex: a #GStaticMutex.
  *
  * Works like g_mutex_unlock(), but for a #GStaticMutex.
@@ -562,7 +566,7 @@ g_static_mutex_get_mutex_impl (GStaticMutex* mutex)
  */
 
 /**
- * g_static_mutex_free:
+ * g_static_mutex_free: (skip):
  * @mutex: a #GStaticMutex to be freed.
  *
  * Releases all resources allocated to @mutex.
@@ -600,7 +604,7 @@ g_static_mutex_free (GStaticMutex* mutex)
 /* {{{1 GStaticRecMutex */
 
 /**
- * GStaticRecMutex:
+ * GStaticRecMutex: (skip):
  *
  * A #GStaticRecMutex works like a #GStaticMutex, but it can be locked
  * multiple times by one thread. If you enter it n times, you have to
@@ -622,7 +626,7 @@ g_static_mutex_free (GStaticMutex* mutex)
  */
 
 /**
- * G_STATIC_REC_MUTEX_INIT:
+ * G_STATIC_REC_MUTEX_INIT: (skip):
  *
  * A #GStaticRecMutex must be initialized with this macro before it can
  * be used. This macro can used be to initialize a variable, but it
@@ -635,7 +639,7 @@ g_static_mutex_free (GStaticMutex* mutex)
  */
 
 /**
- * g_static_rec_mutex_init:
+ * g_static_rec_mutex_init: (skip):
  * @mutex: a #GStaticRecMutex to be initialized.
  *
  * A #GStaticRecMutex must be initialized with this function before it
@@ -683,7 +687,7 @@ g_static_rec_mutex_get_rec_mutex_impl (GStaticRecMutex* mutex)
 }
 
 /**
- * g_static_rec_mutex_lock:
+ * g_static_rec_mutex_lock: (skip):
  * @mutex: a #GStaticRecMutex to lock.
  *
  * Locks @mutex. If @mutex is already locked by another thread, the
@@ -703,7 +707,7 @@ g_static_rec_mutex_lock (GStaticRecMutex* mutex)
 }
 
 /**
- * g_static_rec_mutex_trylock:
+ * g_static_rec_mutex_trylock: (skip):
  * @mutex: a #GStaticRecMutex to lock.
  *
  * Tries to lock @mutex. If @mutex is already locked by another thread,
@@ -732,7 +736,7 @@ g_static_rec_mutex_trylock (GStaticRecMutex* mutex)
 }
 
 /**
- * g_static_rec_mutex_unlock:
+ * g_static_rec_mutex_unlock: (skip):
  * @mutex: a #GStaticRecMutex to unlock.
  *
  * Unlocks @mutex. Another thread will be allowed to lock @mutex only
@@ -753,7 +757,7 @@ g_static_rec_mutex_unlock (GStaticRecMutex* mutex)
 }
 
 /**
- * g_static_rec_mutex_lock_full:
+ * g_static_rec_mutex_lock_full: (skip):
  * @mutex: a #GStaticRecMutex to lock.
  * @depth: number of times this mutex has to be unlocked to be
  *         completely unlocked.
@@ -777,7 +781,7 @@ g_static_rec_mutex_lock_full (GStaticRecMutex *mutex,
 }
 
 /**
- * g_static_rec_mutex_unlock_full:
+ * g_static_rec_mutex_unlock_full: (skip):
  * @mutex: a #GStaticRecMutex to completely unlock.
  *
  * Completely unlocks @mutex. If another thread is blocked in a
@@ -814,7 +818,7 @@ g_static_rec_mutex_unlock_full (GStaticRecMutex *mutex)
 }
 
 /**
- * g_static_rec_mutex_free:
+ * g_static_rec_mutex_free: (skip):
  * @mutex: a #GStaticRecMutex to be freed.
  *
  * Releases all resources allocated to a #GStaticRecMutex.
@@ -843,7 +847,7 @@ g_static_rec_mutex_free (GStaticRecMutex *mutex)
 /* GStaticRWLock {{{1 ----------------------------------------------------- */
 
 /**
- * GStaticRWLock:
+ * GStaticRWLock: (skip):
  *
  * The #GStaticRWLock struct represents a read-write lock. A read-write
  * lock can be used for protecting data that some portions of code only
@@ -922,7 +926,7 @@ g_static_rec_mutex_free (GStaticRecMutex *mutex)
  **/
 
 /**
- * G_STATIC_RW_LOCK_INIT:
+ * G_STATIC_RW_LOCK_INIT: (skip):
  *
  * A #GStaticRWLock must be initialized with this macro before it can
  * be used. This macro can used be to initialize a variable, but it
@@ -935,7 +939,7 @@ g_static_rec_mutex_free (GStaticRecMutex *mutex)
  */
 
 /**
- * g_static_rw_lock_init:
+ * g_static_rw_lock_init: (skip):
  * @lock: a #GStaticRWLock to be initialized.
  *
  * A #GStaticRWLock must be initialized with this function before it
@@ -972,7 +976,7 @@ g_static_rw_lock_signal (GStaticRWLock* lock)
 }
 
 /**
- * g_static_rw_lock_reader_lock:
+ * g_static_rw_lock_reader_lock: (skip):
  * @lock: a #GStaticRWLock to lock for reading.
  *
  * Locks @lock for reading. There may be unlimited concurrent locks for
@@ -1007,7 +1011,7 @@ g_static_rw_lock_reader_lock (GStaticRWLock* lock)
 }
 
 /**
- * g_static_rw_lock_reader_trylock:
+ * g_static_rw_lock_reader_trylock: (skip):
  * @lock: a #GStaticRWLock to lock for reading
  *
  * Tries to lock @lock for reading. If @lock is already locked for
@@ -1041,7 +1045,7 @@ g_static_rw_lock_reader_trylock (GStaticRWLock* lock)
 }
 
 /**
- * g_static_rw_lock_reader_unlock:
+ * g_static_rw_lock_reader_unlock: (skip):
  * @lock: a #GStaticRWLock to unlock after reading
  *
  * Unlocks @lock. If a thread waits to lock @lock for writing and all
@@ -1066,7 +1070,7 @@ g_static_rw_lock_reader_unlock  (GStaticRWLock* lock)
 }
 
 /**
- * g_static_rw_lock_writer_lock:
+ * g_static_rw_lock_writer_lock: (skip):
  * @lock: a #GStaticRWLock to lock for writing
  *
  * Locks @lock for writing. If @lock is already locked for writing or
@@ -1097,7 +1101,7 @@ g_static_rw_lock_writer_lock (GStaticRWLock* lock)
 }
 
 /**
- * g_static_rw_lock_writer_trylock:
+ * g_static_rw_lock_writer_trylock: (skip):
  * @lock: a #GStaticRWLock to lock for writing
  *
  * Tries to lock @lock for writing. If @lock is already locked (for
@@ -1130,7 +1134,7 @@ g_static_rw_lock_writer_trylock (GStaticRWLock* lock)
 }
 
 /**
- * g_static_rw_lock_writer_unlock:
+ * g_static_rw_lock_writer_unlock: (skip):
  * @lock: a #GStaticRWLock to unlock after writing.
  *
  * Unlocks @lock. If a thread is waiting to lock @lock for writing and
@@ -1157,7 +1161,7 @@ g_static_rw_lock_writer_unlock (GStaticRWLock* lock)
 }
 
 /**
- * g_static_rw_lock_free:
+ * g_static_rw_lock_free: (skip):
  * @lock: a #GStaticRWLock to be freed.
  *
  * Releases all resources allocated to @lock.
@@ -1190,7 +1194,7 @@ g_static_rw_lock_free (GStaticRWLock* lock)
 /* GPrivate {{{1 ------------------------------------------------------ */
 
 /**
- * g_private_new:
+ * g_private_new: (skip):
  * @notify: a #GDestroyNotify
  *
  * Creates a new #GPrivate.
@@ -1241,7 +1245,7 @@ g_static_private_cleanup (gpointer data)
 GPrivate static_private_private = G_PRIVATE_INIT (g_static_private_cleanup);
 
 /**
- * GStaticPrivate:
+ * GStaticPrivate: (skip):
  *
  * A #GStaticPrivate works almost like a #GPrivate, but it has one
  * significant advantage. It doesn't need to be created at run-time
@@ -1271,7 +1275,7 @@ GPrivate static_private_private = G_PRIVATE_INIT (g_static_private_cleanup);
  */
 
 /**
- * G_STATIC_PRIVATE_INIT:
+ * G_STATIC_PRIVATE_INIT: (skip):
  *
  * Every #GStaticPrivate must be initialized with this macro, before it
  * can be used.
@@ -1282,7 +1286,7 @@ GPrivate static_private_private = G_PRIVATE_INIT (g_static_private_cleanup);
  */
 
 /**
- * g_static_private_init:
+ * g_static_private_init: (skip):
  * @private_key: a #GStaticPrivate to be initialized
  *
  * Initializes @private_key. Alternatively you can initialize it with
@@ -1295,7 +1299,7 @@ g_static_private_init (GStaticPrivate *private_key)
 }
 
 /**
- * g_static_private_get:
+ * g_static_private_get: (skip):
  * @private_key: a #GStaticPrivate
  *
  * Works like g_private_get() only for a #GStaticPrivate.
@@ -1338,7 +1342,7 @@ g_static_private_get (GStaticPrivate *private_key)
 }
 
 /**
- * g_static_private_set:
+ * g_static_private_set: (skip):
  * @private_key: a #GStaticPrivate
  * @data: the new pointer
  * @notify: a function to be called with the pointer whenever the
@@ -1404,7 +1408,7 @@ g_static_private_set (GStaticPrivate *private_key,
 }
 
 /**
- * g_static_private_free:
+ * g_static_private_free: (skip):
  * @private_key: a #GStaticPrivate to be freed
  *
  * Releases all resources allocated to @private_key.
@@ -1437,7 +1441,7 @@ g_static_private_free (GStaticPrivate *private_key)
 /* GMutex {{{1 ------------------------------------------------------ */
 
 /**
- * g_mutex_new:
+ * g_mutex_new: (skip):
  *
  * Allocates and initializes a new #GMutex.
  *
@@ -1458,7 +1462,7 @@ g_mutex_new (void)
 }
 
 /**
- * g_mutex_free:
+ * g_mutex_free: (skip):
  * @mutex: a #GMutex
  *
  * Destroys a @mutex that has been created with g_mutex_new().
@@ -1479,7 +1483,7 @@ g_mutex_free (GMutex *mutex)
 /* GCond {{{1 ------------------------------------------------------ */
 
 /**
- * g_cond_new:
+ * g_cond_new: (skip):
  *
  * Allocates and initializes a new #GCond.
  *
@@ -1500,7 +1504,7 @@ g_cond_new (void)
 }
 
 /**
- * g_cond_free:
+ * g_cond_free: (skip):
  * @cond: a #GCond
  *
  * Destroys a #GCond that has been created with g_cond_new().
@@ -1519,7 +1523,7 @@ g_cond_free (GCond *cond)
 }
 
 /**
- * g_cond_timed_wait:
+ * g_cond_timed_wait: (skip):
  * @cond: a #GCond
  * @mutex: a #GMutex that is currently locked
  * @abs_time: a #GTimeVal, determining the final time
-- 
GitLab

