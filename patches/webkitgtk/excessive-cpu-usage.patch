From fc158b61f4bedc9bc1a7dd01689a64c225c813d2 Mon Sep 17 00:00:00 2001
From: Philippe Normand <philn@igalia.com>
Date: Wed, 19 Jun 2024 05:15:08 -0700
Subject: [PATCH] REGRESSION(274853@main): [GLib][MSE] Excessive CPU usage from
 cached web process after closing ksdk.com page, failure to display web
 content after reopening page, part 2
 https://bugs.webkit.org/show_bug.cgi?id=274802

Reviewed by Xabier Rodriguez-Calvar.

The excessive CPU usage was due to mediaPlayerReadyStateChanged() recursing on itself forever after
being triggered due to the MediaSource closing procedure. In the WPE/GTK ports at least, the
isSuspended() condition is always true in this situation. The proposed workaround is to attempt a
fixed amount of recursions.

* Source/WebCore/html/HTMLMediaElement.cpp:
(WebCore::HTMLMediaElement::mediaPlayerReadyStateChanged):
* Source/WebCore/html/HTMLMediaElement.h:

Canonical link: https://commits.webkit.org/280171@main
---
 Source/WebCore/html/HTMLMediaElement.cpp | 19 ++++++++++++++++---
 Source/WebCore/html/HTMLMediaElement.h   |  3 +++
 2 files changed, 19 insertions(+), 3 deletions(-)

diff --git a/Source/WebCore/html/HTMLMediaElement.cpp b/Source/WebCore/html/HTMLMediaElement.cpp
index 341830fc09fa..a77313bf5f69 100644
--- a/Source/WebCore/html/HTMLMediaElement.cpp
+++ b/Source/WebCore/html/HTMLMediaElement.cpp
@@ -2889,9 +2889,19 @@ void HTMLMediaElement::changeNetworkStateFromLoadingToIdle()
 void HTMLMediaElement::mediaPlayerReadyStateChanged()
 {
     if (isSuspended()) {
-        queueTaskKeepingObjectAlive(*this, TaskSource::MediaElement, [this] {
-            mediaPlayerReadyStateChanged();
-        });
+        // FIXME: In some situations the MediaSource closing procedure triggerring a readyState
+        // update on the player, while the media element is suspended would lead to infinite
+        // recursion. The workaround is to attempt a fixed amount of recursions.
+        if (!m_isChangingReadyStateWhileSuspended) {
+            m_isChangingReadyStateWhileSuspended = true;
+            m_remainingReadyStateChangedAttempts.store(128);
+        }
+
+        if (m_remainingReadyStateChangedAttempts.exchangeSub(1)) {
+            queueTaskKeepingObjectAlive(*this, TaskSource::MediaElement, [this] {
+                mediaPlayerReadyStateChanged();
+            });
+        }
         return;
     }
 
@@ -2900,6 +2910,9 @@ void HTMLMediaElement::mediaPlayerReadyStateChanged()
     setReadyState(m_player->readyState());
 
     endProcessingMediaPlayerCallback();
+
+    m_isChangingReadyStateWhileSuspended = false;
+    m_remainingReadyStateChangedAttempts.store(0);
 }
 
 Expected<void, MediaPlaybackDenialReason> HTMLMediaElement::canTransitionFromAutoplayToPlay() const
diff --git a/Source/WebCore/html/HTMLMediaElement.h b/Source/WebCore/html/HTMLMediaElement.h
index 0a87c1f42471..45ca559b80c8 100644
--- a/Source/WebCore/html/HTMLMediaElement.h
+++ b/Source/WebCore/html/HTMLMediaElement.h
@@ -1397,6 +1397,9 @@ class HTMLMediaElement
 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
     Ref<RemotePlayback> m_remote;
 #endif
+
+    bool m_isChangingReadyStateWhileSuspended { false };
+    Atomic<unsigned> m_remainingReadyStateChangedAttempts;
 };
 
 String convertEnumerationToString(HTMLMediaElement::AutoplayEventPlaybackState);
