From 07694d947718628a0ee5761726e2c2f518792b24 Mon Sep 17 00:00:00 2001
From: Michael Catanzaro <mcatanzaro@redhat.com>
Date: Thu, 20 Jun 2024 15:27:25 -0500
Subject: [PATCH] [WPE][GTK] Web process cache suspend/resume does not work,
 WebProcessProxy::processIdentifier is not the pid of the actual web process
 https://bugs.webkit.org/show_bug.cgi?id=262794

Reviewed by NOBODY (OOPS!).

We'll use Unix credentials to send the actual pid of the child process
to the parent process.

This could be done using the WebKit IPC connection, but the code is
much simpler if we create a separate socket for this.

* Source/WebKit/Platform/IPC/IPCUtilities.h:
* Source/WebKit/Platform/IPC/unix/ConnectionUnix.cpp:
(IPC::createPlatformConnection):
(IPC::sendPIDToPeer):
(IPC::readPIDFromPeer):
* Source/WebKit/Shared/unix/AuxiliaryProcessMain.cpp:
(WebKit::AuxiliaryProcessMainCommon::parseCommandLine):
* Source/WebKit/UIProcess/Launcher/glib/ProcessLauncherGLib.cpp:
(WebKit::ProcessLauncher::launchProcess):
---
 Source/WebKit/Platform/IPC/IPCUtilities.h     |  8 +++
 .../Platform/IPC/unix/ConnectionUnix.cpp      | 61 +++++++++++++++++++
 .../Shared/unix/AuxiliaryProcessMain.cpp      | 34 ++++++++++-
 .../Launcher/glib/ProcessLauncherGLib.cpp     | 34 ++++++++---
 4 files changed, 126 insertions(+), 11 deletions(-)

diff --git a/Source/WebKit/Platform/IPC/IPCUtilities.h b/Source/WebKit/Platform/IPC/IPCUtilities.h
index 19e338866bf2..35290d74ae38 100644
--- a/Source/WebKit/Platform/IPC/IPCUtilities.h
+++ b/Source/WebKit/Platform/IPC/IPCUtilities.h
@@ -56,9 +56,17 @@ struct SocketPair {
 enum PlatformConnectionOptions {
     SetCloexecOnClient = 1 << 0,
     SetCloexecOnServer = 1 << 1,
+#if OS(LINUX)
+    SetPasscredOnServer = 1 << 2
+#endif
 };
 
 SocketPair createPlatformConnection(unsigned options = SetCloexecOnClient | SetCloexecOnServer);
+
+#if USE(GLIB) && OS(LINUX)
+void sendPIDToPeer(int socket);
+pid_t readPIDFromPeer(int socket);
+#endif
 #endif
 
 #if OS(WINDOWS)
diff --git a/Source/WebKit/Platform/IPC/unix/ConnectionUnix.cpp b/Source/WebKit/Platform/IPC/unix/ConnectionUnix.cpp
index a73735c95dfd..bc56e0f824a3 100644
--- a/Source/WebKit/Platform/IPC/unix/ConnectionUnix.cpp
+++ b/Source/WebKit/Platform/IPC/unix/ConnectionUnix.cpp
@@ -561,6 +561,11 @@ SocketPair createPlatformConnection(unsigned options)
             RELEASE_ASSERT_NOT_REACHED();
     }
 
+    if (options & SetPasscredOnServer) {
+        int enable = 1;
+        RELEASE_ASSERT(!setsockopt(sockets[1], SOL_SOCKET, SO_PASSCRED, &enable, sizeof(enable)));
+    }
+
     SocketPair socketPair = { sockets[0], sockets[1] };
     return socketPair;
 }
@@ -570,4 +575,60 @@ std::optional<Connection::ConnectionIdentifierPair> Connection::createConnection
     SocketPair socketPair = createPlatformConnection();
     return ConnectionIdentifierPair { Identifier { UnixFileDescriptor { socketPair.server,  UnixFileDescriptor::Adopt } }, UnixFileDescriptor { socketPair.client, UnixFileDescriptor::Adopt } };
 }
+
+#if USE(GLIB) && OS(LINUX)
+void sendPIDToPeer(int socket)
+{
+    char buffer[1] = { 0 };
+    struct msghdr message = { };
+    struct iovec iov = { buffer, sizeof(buffer) };
+
+    // Write one null byte. Credentials will be attached regardless of what we send.
+    message.msg_iov = &iov;
+    message.msg_iovlen = 1;
+
+    if (sendmsg(socket, &message, 0) == -1)
+        g_error("sendPIDToPeer: Failed to send pid: %s", g_strerror(errno));
+}
+
+// The goal here is to receive the pid of the sandboxed child in the parent process's pid namespace.
+// It's impossible for the child to know this, but the kernel will translate it for us.
+//
+// Based on read_pid_from_socket() from bubblewrap's utils.c
+// SPDX-License-Identifier: LGPL-2.0-or-later
+pid_t readPIDFromPeer(int socket)
+{
+    char receiveBuffer[1] = { 0 };
+    struct msghdr message = { };
+    struct iovec iov = { receiveBuffer, sizeof(receiveBuffer) };
+    const ssize_t controlLength = CMSG_SPACE(sizeof(struct ucred));
+    union {
+        char buffer[controlLength];
+        cmsghdr forceAlignment;
+    } controlMessage;
+
+    message.msg_iov = &iov;
+    message.msg_iovlen = 1;
+    message.msg_control = controlMessage.buffer;
+    message.msg_controllen = controlLength;
+
+    if (recvmsg(socket, &message, 0) == -1)
+        g_error("readPIDFromPeer: Failed to read pid from PID socket: %s", g_strerror(errno));
+
+    if (message.msg_controllen <= 0)
+        g_error("readPIDFromPeer: Unexpected short read from PID socket");
+
+    for (cmsghdr* header = CMSG_FIRSTHDR(&message); header; header = CMSG_NXTHDR(&message, header)) {
+        const unsigned payloadLength = header->cmsg_len - CMSG_LEN(0);
+        if (header->cmsg_level == SOL_SOCKET && header->cmsg_type == SCM_CREDENTIALS && payloadLength == sizeof(struct ucred)) {
+            struct ucred credentials;
+            memcpy(&credentials, CMSG_DATA(header), sizeof(struct ucred));
+            return credentials.pid;
+        }
+    }
+
+    g_error("readPIDFromPeer: No pid returned on PID socket");
+}
+#endif
+
 } // namespace IPC
diff --git a/Source/WebKit/Shared/unix/AuxiliaryProcessMain.cpp b/Source/WebKit/Shared/unix/AuxiliaryProcessMain.cpp
index 5bae771f7b19..44fa675fe6e7 100644
--- a/Source/WebKit/Shared/unix/AuxiliaryProcessMain.cpp
+++ b/Source/WebKit/Shared/unix/AuxiliaryProcessMain.cpp
@@ -36,6 +36,8 @@
 #include "unix/BreakpadExceptionHandler.h"
 #endif
 
+#include "IPCUtilities.h"
+
 namespace WebKit {
 
 AuxiliaryProcessMainCommon::AuxiliaryProcessMainCommon()
@@ -45,18 +47,44 @@ AuxiliaryProcessMainCommon::AuxiliaryProcessMainCommon()
 #endif
 }
 
+// The command line is constructed in ProcessLauncher::launchProcess.
 bool AuxiliaryProcessMainCommon::parseCommandLine(int argc, char** argv)
 {
-    ASSERT(argc >= 3);
-    if (argc < 3)
+#if OS(LINUX)
+    int minimumNumArgs = 4;
+#else
+    int minimumNumArgs = 3;
+#endif
+
+#if USE(LIBWPE) && !ENABLE(BUBBLEWRAP_SANDBOX)
+    if (ProcessProviderLibWPE::singleton().isEnabled())
+        minimumNumArgs = 3;
+#endif
+
+    if (argc < minimumNumArgs)
         return false;
 
     m_parameters.processIdentifier = ObjectIdentifier<WebCore::ProcessIdentifierType>(atoll(argv[1]));
     m_parameters.connectionIdentifier = IPC::Connection::Identifier { atoi(argv[2]) };
+    if (!m_parameters.processIdentifier || !m_parameters.connectionIdentifier)
+        return false;
+
+#if OS(LINUX)
+    if (minimumNumArgs == 4) {
+        int pidSocket = atoi(argv[3]);
+        if (!pidSocket)
+            return false;
+
+        IPC::sendPIDToPeer(pidSocket);
+        RELEASE_ASSERT(!close(pidSocket));
+    }
+#endif
+
 #if ENABLE(DEVELOPER_MODE)
-    if (argc > 3 && argv[3] && !strcmp(argv[3], "--configure-jsc-for-testing"))
+    if (argc > minimumNumArgs && argv[minimumNumArgs] && !strcmp(argv[minimumNumArgs], "--configure-jsc-for-testing"))
         JSC::Config::configureForTesting();
 #endif
+
     return true;
 }
 
diff --git a/Source/WebKit/UIProcess/Launcher/glib/ProcessLauncherGLib.cpp b/Source/WebKit/UIProcess/Launcher/glib/ProcessLauncherGLib.cpp
index 4ba7b1996747..db6428263495 100644
--- a/Source/WebKit/UIProcess/Launcher/glib/ProcessLauncherGLib.cpp
+++ b/Source/WebKit/UIProcess/Launcher/glib/ProcessLauncherGLib.cpp
@@ -119,10 +119,12 @@ static bool isSandboxEnabled(const ProcessLauncher::LaunchOptions& launchOptions
 
 void ProcessLauncher::launchProcess()
 {
-    IPC::SocketPair socketPair = IPC::createPlatformConnection(connectionOptions());
+    RELEASE_ASSERT(m_launchOptions.processType != ProcessLauncher::ProcessType::DBusProxy);
 
     GUniquePtr<gchar> processIdentifier(g_strdup_printf("%" PRIu64, m_launchOptions.processIdentifier.toUInt64()));
-    GUniquePtr<gchar> webkitSocket(g_strdup_printf("%d", socketPair.client));
+
+    IPC::SocketPair webkitSocketPair = IPC::createPlatformConnection(connectionOptions());
+    GUniquePtr<gchar> webkitSocket(g_strdup_printf("%d", webkitSocketPair.client));
 
 #if USE(LIBWPE) && !ENABLE(BUBBLEWRAP_SANDBOX)
     if (ProcessProviderLibWPE::singleton().isEnabled()) {
@@ -133,12 +135,12 @@ void ProcessLauncher::launchProcess()
         argv[i++] = webkitSocket.get();
         argv[i++] = nullptr;
 
-        m_processID = ProcessProviderLibWPE::singleton().launchProcess(m_launchOptions, argv, socketPair.client);
+        m_processID = ProcessProviderLibWPE::singleton().launchProcess(m_launchOptions, argv, webkitSocketPair.client);
         if (m_processID <= -1)
             g_error("Unable to spawn a new child process");
 
         // We've finished launching the process, message back to the main run loop.
-        RunLoop::main().dispatch([protectedThis = Ref { *this }, this, serverSocket = socketPair.server] {
+        RunLoop::main().dispatch([protectedThis = Ref { *this }, this, serverSocket = webkitSocketPair.server] {
             didFinishLaunchingProcess(m_processID, IPC::Connection::Identifier { serverSocket });
         });
 
@@ -146,6 +148,11 @@ void ProcessLauncher::launchProcess()
     }
 #endif
 
+#if OS(LINUX)
+    IPC::SocketPair pidSocketPair = IPC::createPlatformConnection(IPC::PlatformConnectionOptions::SetCloexecOnClient | IPC::PlatformConnectionOptions::SetCloexecOnServer | IPC::PlatformConnectionOptions::SetPasscredOnServer);
+    GUniquePtr<gchar> pidSocket(g_strdup_printf("%d", pidSocketPair.client));
+#endif
+
     String executablePath;
     CString realExecutablePath;
     switch (m_launchOptions.processType) {
@@ -166,7 +173,7 @@ void ProcessLauncher::launchProcess()
     }
 
     realExecutablePath = FileSystem::fileSystemRepresentation(executablePath);
-    unsigned nargs = 4; // size of the argv array for g_spawn_async()
+    unsigned nargs = 5; // size of the argv array for g_spawn_async()
 
 #if ENABLE(DEVELOPER_MODE)
     Vector<CString> prefixArgs;
@@ -193,6 +200,7 @@ void ProcessLauncher::launchProcess()
     argv[i++] = const_cast<char*>(realExecutablePath.data());
     argv[i++] = processIdentifier.get();
     argv[i++] = webkitSocket.get();
+    argv[i++] = pidSocket.get();
 #if ENABLE(DEVELOPER_MODE)
     if (configureJSCForTesting)
         argv[i++] = const_cast<char*>("--configure-jsc-for-testing");
@@ -209,7 +217,10 @@ void ProcessLauncher::launchProcess()
     //
     // Please keep this comment in sync with the duplicate comment in XDGDBusProxy::launch.
     GRefPtr<GSubprocessLauncher> launcher = adoptGRef(g_subprocess_launcher_new(G_SUBPROCESS_FLAGS_INHERIT_FDS));
-    g_subprocess_launcher_take_fd(launcher.get(), socketPair.client, socketPair.client);
+    g_subprocess_launcher_take_fd(launcher.get(), webkitSocketPair.client, webkitSocketPair.client);
+#if OS(LINUX)
+    g_subprocess_launcher_take_fd(launcher.get(), pidSocketPair.client, pidSocketPair.client);
+#endif
 
     GUniqueOutPtr<GError> error;
     GRefPtr<GSubprocess> process;
@@ -218,7 +229,7 @@ void ProcessLauncher::launchProcess()
     bool sandboxEnabled = isSandboxEnabled(m_launchOptions);
 
     if (sandboxEnabled && isFlatpakSpawnUsable())
-        process = flatpakSpawn(launcher.get(), m_launchOptions, argv, socketPair.client, &error.outPtr());
+        process = flatpakSpawn(launcher.get(), m_launchOptions, argv, webkitSocketPair.client, &error.outPtr());
 #if ENABLE(BUBBLEWRAP_SANDBOX)
     // You cannot use bubblewrap within Flatpak or some containers so lets ensure it never happens.
     // Snap can allow it but has its own limitations that require workarounds.
@@ -232,15 +243,22 @@ void ProcessLauncher::launchProcess()
     if (!process.get())
         g_error("Unable to spawn a new child process: %s", error->message);
 
+#if OS(LINUX)
+    m_processID = IPC::readPIDFromPeer(pidSocketPair.server);
+
+    RELEASE_ASSERT(!close(pidSocketPair.server));
+    RELEASE_ASSERT(!close(pidSocketPair.client));
+#else
     const char* processIdStr = g_subprocess_get_identifier(process.get());
     if (!processIdStr)
         g_error("Spawned process died immediately. This should not happen.");
 
     m_processID = g_ascii_strtoll(processIdStr, nullptr, 0);
     RELEASE_ASSERT(m_processID);
+#endif
 
     // We've finished launching the process, message back to the main run loop.
-    RunLoop::main().dispatch([protectedThis = Ref { *this }, this, serverSocket = socketPair.server] {
+    RunLoop::main().dispatch([protectedThis = Ref { *this }, this, serverSocket = webkitSocketPair.server] {
         didFinishLaunchingProcess(m_processID, IPC::Connection::Identifier { serverSocket });
     });
 }
